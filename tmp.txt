
	Q_PROPERTY(qsizetype toReviewCount READ toReviewCount NOTIFY toReviewCountChanged);
	Q_INVOKABLE bool goNext(DeckMode mode = DeckMode::Review);
	std::vector<QString> decksFiles; // TODO questo full path
	std::vector<QString> getDecksFiles() const;

QStringList DeckManager::availableDecksNames() const
{
	QStringList temp_availableDecksNames;
	temp_availableDecksNames.reserve(decksFiles.size());
	
	for(const auto& deckFile : decksFiles)
		temp_availableDecksNames.emplace_back(QFileInfo(deckFile).baseName());

	return temp_availableDecksNames;
}

	Q_PROPERTY(QStringList availableDecksNames READ availableDecksNames NOTIFY availableDecksNamesChanged);

qsizetype DeckManager::toReviewCount() const
{
	return std::ranges::count_if(currentDeck->cardsView(), [](Card c){return c.toReview();});
}

std::vector<QString> DeckManager::getDecksFiles() const
{	
	QDir dataDir(QStandardPaths::writableLocation(QStandardPaths::AppDataLocation));
	QFileInfoList fileList = dataDir.entryInfoList(QStringList("*.json"), QDir::Files);

	std::vector<QString> ret;
	ret.reserve(fileList.size());

	//TODO use functional style std::transform
	for(const QFileInfo &fileInfo : fileList)
		ret.emplace_back(fileInfo.absoluteFilePath());

	return ret;
}
QVariantMap DeckManager::createCard() const
{
	QMap<QString, QVariant> temp_currentCard;

	if(!m_currentCard || !currentDeck) 
		return temp_currentCard;

	temp_currentCard.insert("q", currentDeck->getCardAt(*m_currentCard).getQuestion());
	temp_currentCard.insert("a", currentDeck->getCardAt(*m_currentCard).getAnswer());

	return temp_currentCard;
}
	Q_PROPERTY(QVariantMap currentCard READ currentCard NOTIFY currentCardChanged);
